# 2 리팩터링 원칙

## 2.2 두개의 모자

소프트웨어 개발의 목적을 명확히 구분해서 작업한다. 기능 추가를 할 때는 "기능 추가" 모자를 쓴 다음 기존 코드는 절대 수정하지 않는다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다. 반면 리팩터링을 할때는 "리팩터링" 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에 전념한다. 놓친 테스트케이스를 새로 발견하는것이 아니면 테스트도 새로 만들지 않는다. (부득이 인터페이스를 변경해야 할 때만 코드 재구성에 전념한다.)

## 2.3 리팩터링을 하는 이유

### 리팩터링하면 소프트웨어 설계가  좋아진다.

같은일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 사실강 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다. 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심이다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

단지 다른사람을 배려하기 위해서가 아니라, 사실 그 다른사람이 나 자신일 경우가 많기때문에 리팩터링이 더더욱 중요하다. 

### 리팩터링하면 버그를 쉽게 찾을 수 있다

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 프로그램의 구조를 명확하게 다듬으면 그냥 "이럴 것 이다"라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

한 시스템을 오래 개발하다보면 시간이 갈수록 새로운 기능을 코드베이스에 녹여내는데에 걸리는 시간이 훨씬 오래걸린다.

처음부터 좋은 설계를 마련하는것은 매우 어렵다. 리팩터링을 통하면 기존코드의 설계를 얼마든지 개선할 수 있으므로, 설령 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.

## 2.4 언제 리팩터링을 해야할까?

> 3의 법칙
> 
> 1. 처음에는 그냥 한다.
> 
> 2. 비슷한 일을 두번째로 진행하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
> 
> 3. 비슷한 일을 세번째 하게되면 리팩터링 한다.

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링을 하기 가장 좋은 시점은 코드베이스에 기능을 추가하기 직전이다.이 시점에서 구조를 바꾸면 다른 작업을 하기가 훨씬 쉬워질만한 부분을 찾는다.

리팩터링 모자를 쓰고 중복되는 부분을 찾아 <strong>함수 매개변수화하기</strong>를 적용한다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

리팩터링하면 머리로 이해한것을 코드에 옮겨 담을 수 있다. 런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다.

코드를 분석할때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다.

### 쓰레기 줍기 리팩터링

로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러개로 작성해놨을 수 있다.간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 짧은 일은 메모만 남긴 다음, 하던 일을 끝내고서 처리한다.

이것을 쓰레기 줍기 리팩터링이라고 한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

리팩터링을 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기 쉽다. 보기싫은 코드를 보면 리팩터링 해야 함은 당연하지만, 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할때는 먼저 수정하기 쉽게 정돈하고 (단, 만만치 않을 수 있다)
> 
> 그런 다음 쉽게 수정하자.

소프트웨어 개발을 끝이 있는 작업으로 보면 안 된다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정된다. 이때 새로 작성하는 코드보다 기존코드 수정량이 큰 경우가 대체로 많다.

버전 관리 시스템에서 리팩터링과 기능 추가 커밋을 분리해야 한다는 조언이 있다. 하지만 필자는 이 견해에 완전히 동의하지는 않는다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기때문에 굳이 나누는 것은 시간 낭비 일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워 진다.

### 리팩터링을 하지 말아야 할 때

외부 API 다루듯 호출해서 쓰는 코드라면 지저분해도 수정하지 않는다. 내부 동작을 이해해야 할 시점에 리팩터링을 해야 제대로 효과를 볼 수 있다.

리팩터링하는 것보다 처음부터 새로작성하는게 쉬울때도 리팩터링 하지 않는다.

## 2.5 리팩터링시 고려할 문제

### 새 기능 개발속도 저하?

사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는것이다. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. <strong>오로지 경제적인 이유로 하는 것이다.</strong>

## 코드 소유권

팀이 작성한 코드에 대해서는 누구나 수정할 수 있도록 하는것이, 의미없이 인터페이스를 수정하느라 날리는 시간을 절약해 수 있다.

### 브랜치

기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 하는 사람이 많다. 한편 저자와 같은 사람은 더 짧아야 한다고 주장하는데 이 방식을 CI(Continuous Integration), 또는 TBD(Trunk Based Development)이라 한다.

CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다. 이렇게 하면 다른 브랜치들고아ㅢ 차이가 크게 벌어지는 브랯니가 없어져서 머지의 복잡도를 상당히 낮출 수 있다.

하지만 CI를 적용하기 위해서는 치러야 할 대가가 있다. 마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

### 테스팅

리팩터링을 하기 위해서는 (대부분의 경우에) 자가 테스트 코드를 마련해야 한다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)
